# DnD++ - Dungeon and Dragons inspired Programming Language

Welcome to my first experiment building my own programming language which is showcased on my YouTube Channel ILTPWC.

DnD++ is a Dungeons & Dragons-inspired programming language designed for those who want to bring some excitement and creativity to their coding adventures. 
This project provides a lexer, parser, interpreter, and compiler for the DnD++ programming language, as well as example code to demonstrate its syntax and usage.

And please don't take it to serious!


## Language Overview

The DnD++ programming language uses a syntax inspired by Dungeons & Dragons adventures, with a focus on storytelling and imaginative descriptions. Variable declarations, for example, are written as follows:

`In the realm of YouTube, a hero was born called ian. The hero wields a mighty sword, forged with the power of 10.`

This declaration is equivalent to the following code in C++:

`int ian = 10;`

## Getting Started

To start using the DnD++ programming language, clone this repository and install the required dependencies:

`git clone https://github.com/your-username/dndpp.git`

Once you have the repository cloned, follow the instructions in the subsequent sections to tokenize, parse, interpret, and compile DnD++ code.

This project includes a lexer, parser, interpreter, and compiler for the DnD++ programming language. You can find their implementations in their subfolders lexer, parser, compiler, interpreter, respectively.

To tokenize, parse, interpret, or compile DnD++ code, follow these steps:

1. Write your DnD++ code in a text file, e.g., example.dndpp.
2. Use the main.py example.dndpp to generate a .asm file
3. Assembe the .asm file with NASM and link the object file with GCC after that generate the executable

`nasm -f elf64 example.asm -o example.o`
`gcc example.o -o example`
`./example`


And the most important think have fun! and try to play the adventure with your DnD Party.


### Lexer

The Lexer takes the source code as input and breaks it into a sequence of tokens, each of which has a type and a value. At this early stage of the development of DnD++ it only identifies various tokens including heroes (which represent variable names), weapons (which represent different variable types), and numbers or string/boolean values.

The Lexer uses a set of regular expressions to match the different token types in the source code. The regular expressions cover the diverse narrative possibilities of the DnD++ syntax. Here are some of the main types of tokens:

Heroes (variable declarations): Identified by keywords like hero, mage, knight, rogue, druid, oracle, bard, shaman or monk followed by called and the name of the variable.

Integers: Defined by fantasy melee weapons like sword, axe, club, dagger, mace followed by a whole number. Assignment is done using keywords like forged, carved, crafted.

Floats: Defined by fantasy ranged weapons like bow, sling, dart, crossbow followed by a floating point number. Assignment is done using keywords like forged, carved, mixed, brewed, crafted.

Strings: Defined by keywords like sang, composed, whispered, inscribed, penned followed by the string value in quotation marks.

Booleans: Defined by keywords like swore, named, invoked followed by truth or falsehood to assign the boolean value.

Remember, in DnD++, every word that isn't a token will be treated as a comment regardless of the position within the code.


### Parser

The Parser takes the sequence of tokens generated by the Lexer and organizes them into an Abstract Syntax Tree (AST). The AST represents the grammatical structure of the source code according to the rules defined for DnD++ syntax.

The Parser analyzes the tokens in order and expects them to follow certain patterns based on the DnD++ language's grammar rules. The primary constructs it looks for are variable declarations and assignments, which include the variable type, variable name and value. Everything else will follow soon.

Here are some of the main structures the Parser creates:

Variable Declarations: The Parser recognizes a new variable when it encounters a token of type HERO. It then expects a variable name (token of type HERO_NAME), followed by a token representing the variable type (which can be INTEGER_SWORD, FLOAT_BOW, STRING_SONG, or BOOLEAN_OATH).

Assignments: The Parser recognizes an assignment when it encounters a token of type ASSIGNMENT_ACTION (which can be forged, carved, mixed, brewed, crafted, sang, composed, whispered, inscribed, penned, swore, named, invoked). It then expects a value that matches the variable type previously declared.

The output of the Parser is an Abstract Syntax Tree (AST) which is used by the Interpreter or Compiler to execute or generate assembly code respectively.


### Interpreter

ToDo: Add Content


### Compiler

Will use LLVM in future.

## Examples

The following example demonstrates how to declare and initialize a variable in the DnD++ programming language:

`In the realm of Variables, a legendary hero was born called healthPoints. The hero wields a mighty Sword, forged with the power of 100`


## Contributing

We welcome contributions from the community! If you have any ideas, suggestions, or improvements for the DnD++ programming language, please feel free to submit an issue or pull request.

## Support

If you want to support me please consider to like the YouTube Video about the DnD++ Language and subscribe to my Channel ILTPWC(http://www.youtube.com/@ILTPWC)

